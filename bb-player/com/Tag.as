package com {	import flash.display.*;	import flash.events.*;	import flash.utils.Timer;	import flash.net.*;	import flash.ui.Mouse;	import flash.system.Security;	import flash.system.SecurityPanel;	import flash.geom.*;	import flash.utils.*;	import com.TagPoint;	// ---------------------------------------	public class Tag extends Sprite {		// tag xml		public var GML:	      XML;		public var tagXML:		XML;		public var tagHeader:	XML;		public var tagData:	  XML;			public var tagPoints:Array 	= new Array();		public var bLoaded:Boolean 	= false;		public var tagCount:Number	    = 0;		public var totalStrokes:Number	= 0;		public var totalPoints:Number	  = 0;		public var pos:Point	= new Point(0,0);		public var des:Point	= new Point(0,0);		// points		public var pts:Array = new Array();				// array for all the points		// Time		var startTime:Number	= 0.0;		var maxNumPts:Number	= 0.0;		var ptStart:Number		      = 0.0;				// start and end points. if not edited ptStart = 0 and ptEnd = lastPoint		var ptEnd:Number			      = 0.0;		var timeCounter:Number		  = 0.0;				// time change for playback		var timeOfLastFrame:Number	= 0.0;				// records last time to calc time change		var timeInRange:Number		  = 0.0;				// current time in the drawing		var nowIndex:Number			= 0.0;				// last point recorder or last point to be drawn		var nowDist:Number			= 0.0;				// time interpolated distance		var nowAngle:Number			= 0.0;				// time interpolated angle		var nowPointForTime:Point 	= new Point();		// time interpolated point		var bPaused:Boolean			= false;		var bReset:Boolean			= false;		var bPlayed:Boolean			= false;		// --------------------------------------- construct		public function Tag() {			startTime			= 0.0;			maxNumPts			= 5000;			ptStart				= 0;			ptEnd				= 0;			timeCounter			= 0.0;			timeOfLastFrame		= 0.0;			timeInRange			= 0.00;			nowIndex			= 0;			nowDist				= 0.0;			nowAngle			= 0.0;			nowPointForTime.x	= 0;			nowPointForTime.y	= 0;			//rotation.set(0,0,0);			//position.set(0,0,0);			//z_const     = 16;			//bPlayed = false;		}		// --------------------------------------- load tag		public function loadTag(path:String) {			// load the settings			var tagLdr:URLLoader = new URLLoader(new URLRequest(path));			tagLdr.addEventListener(Event.COMPLETE, tagLoaded);		}		// --------------------------------------- tag is loaded		public function tagLoaded(e:Event) {			GML = new XML(e.target.data);			GML.ignoreWhitespace = true;            tagXML = new XML(GML.child(0));			tagHeader = new XML(tagXML.child(0));			tagData = new XML(tagXML.child(1)); // skip right to first stroke			// tag values			totalStrokes = tagData.children().length();			trace("totalStrokes: "+totalStrokes);			// create the tag recording points			for (var i=0; i < tagData.children().length(); i++) {        var tagStroke = tagData.child(i);        var numStrokes:Number = tagStroke.children().length();        trace("tagStroke: "+i+" numStrokes:"+numStrokes);        for (var j=0; j < numStrokes; j++) {  				var tag_p:Point	 = new Point(tagStroke.child(j).x,tagStroke.child(j).y);  				var tag_t:Number = tagStroke.child(j).time;  				var tag_a:Number = tagStroke.child(j).angle;  				var tag_d:Number = tagStroke.child(j).dist;  				// if (i == totalStrokes-1) {  				// 	tag_d=0;  				// }  				addNewPoint(tag_p, tag_d, -1, tag_t, false);  			}  		}			bLoaded=true;		}		// data		public function getVelocityForTime(time:Number):Point {			// ok the trick is to do the same as above (find the time in the gesture)			// and to find a time slightly less... (prev position and current position).			if (pts.length<=0) {				return new Point(0, 0);			}			var totalTime:Number=getDuration();			var timeInRange:Number=time;			while (timeInRange > totalTime) {				timeInRange-=totalTime;			}			var prevTime:Number=Math.max(0,timeInRange-0.016666);// time minus 1/60 of a second....			//cout << timeInRange << " " << prevTime << endl;			var curPoint:Point=getPointForTime(timeInRange);			var prevPoint:Point=getPointForTime(prevTime);			var velocity:Point = new Point();			velocity.x=curPoint.x-prevPoint.x;			velocity.y=curPoint.y-prevPoint.y;			return velocity;		}//getVelocityForTime		public function getCurrentPoint():Point {			return nowPointForTime;		}		public function getDuration():Number {			var totalDuration:Number=0;			if (pts.length>0) {				totalDuration=pts[ptEnd].time;			}			return totalDuration;		}		public function getCurentZDepth():Number {			return 0;		}		public function getPctDone():Number {			if (pts.length==0) {				return 0;			} else {				return (pts[ptEnd].time - pts[nowIndex].time) / pts[ptEnd].time;			}		}		public function getCurrentTime():Number {			return timeInRange;		}		public function getCurrentAngle():Number {			return nowAngle;		}		public function getTimeCounter():Number {			return timeCounter;		}		public function getIdCurrent():Number {			return nowIndex;		}		public function getNumPts():Number {			return pts.length;		}		public function getStartPt():Number {			return ptStart;		}		public function getEndPt():Number {			return ptEnd;		}		public function getElapsedTime():Number {			var t:String  = String(getTimer());			var tt:Number = Number(t) * 0.001;			return tt;		}		// --------------------------------------- 		public function calculateStrip(pntsArray:Array, scalex:Number, scaley:Number) {			var i:int=0;			// set the off set			for (i=1; i<pntsArray.length; i++) {				var g 				= 10;				var angle 			= Math.atan2(pntsArray[i-1].pos.y - pntsArray[i].pos.y, pntsArray[i].pos.x - pntsArray[i-1].pos.x);				pntsArray[i].offx   = Math.sin(angle) * g * ( Math.sin( Math.PI/(pntsArray.length-1) * i) );				pntsArray[i].offy   = Math.cos(angle) * g * ( Math.sin( Math.PI/(pntsArray.length-1) * i) );			}			// build the quad			for (i=1; i<pntsArray.length; i++) {				pntsArray[i].x1 = (pntsArray[i].pos.x * scalex) + pntsArray[i].offx;				pntsArray[i].y1 = (pntsArray[i].pos.y * scaley) + pntsArray[i].offy;				pntsArray[i].x2 = (pntsArray[i].pos.x * scalex) - pntsArray[i].offx;				pntsArray[i].y2 = (pntsArray[i].pos.y * scaley) - pntsArray[i].offy;				pntsArray[i].x3 = (pntsArray[i-1].pos.x * scalex) - pntsArray[i-1].offx;				pntsArray[i].y3 = (pntsArray[i-1].pos.y * scaley) - pntsArray[i-1].offy;				pntsArray[i].x4 = (pntsArray[i-1].pos.x * scalex) + pntsArray[i-1].offx;				pntsArray[i].y4 = (pntsArray[i-1].pos.y * scaley) + pntsArray[i-1].offy;			}		}//calculateStrip		// --------------------------------------- add a new tag point		public function addNewPoint(pt:Point, dist:Number, angle:Number, time:Number, bAverage:Boolean):Boolean {			//---------------- ignore 0,0 error			if (pt.x == 0 && pt.y == 0) {				return false;			}			//-------------- try to add the point			// on the first point, grab the start time			if (pts.length==0) {				startTime=getElapsedTime();			}			// combine the position and the time here:			var myPoint:TagPoint = new TagPoint();			myPoint.pos=pt;			if (time==-1) {				myPoint.time=getElapsedTime()-startTime;			} else {				myPoint.time=time;			}// check distance and return if too small			if (pts.length>0&&dist==-1) {				dist=pts[pts.length-1].pos.subtract(pt).length();			} else if ( pts.length == 0 && dist == -1 ) {				dist=0;			}			if (pts.length==0||dist>0.0001) {				myPoint.dist=dist;			} else {				return false;			}			if (pts.length>0&&angle==-1) {				angle=Math.atan2(pt.y-pts[pts.length-1].pos.y,pt.x-pts[pts.length-1].pos.x);			} else if (angle == -1) {				angle=0;			}			myPoint.angle=angle;			// add and check if point is misplaced			var inPt:Number=-1;			for (var i = 0; i < pts.length; i++) {				if (pts[i].time>time) {					inPt=i;					break;				}			}			if (inPt==-1) {				pts.push(myPoint);				//pts_orig.push_back(myPoint);			} else {				pts.unshift(myPoint);				//pts_orig.insert(pts_orig.begin()+inPt,myPoint);			}			// delete if overrun limit			if (pts.length>maxNumPts) {				//pts				//pts.erase(pts.begin());			}			var numPoints:Number = pts.length-1;			//------------- average			if (numPoints>1&&bAverage) {				//pts[numPoints-1].pos.x = (0.2f * pts[numPoints-2].pos.x) + (0.60f * pts[numPoints-1].pos.x) + (0.2f * pts[numPoints].pos.x);				//pts[numPoints-1].pos.y = (0.2f * pts[numPoints-2].pos.y) + (0.60f * pts[numPoints-1].pos.y) + (0.2f * pts[numPoints].pos.y);				//pts[numPoints-1].dist  = (0.25f * pts[numPoints-2].dist)  + (0.50f * pts[numPoints-1].dist)  + (0.25f * pts[numPoints].dist);			}			ptEnd = pts.length - 1;			// save originals			//if(pts_orig.size() > maxNumPts) {			//pts_orig.erase(pts_orig.begin());			//}			return true;		}//addNewPoint		// --------------------------------------- get point from time		public function getPointForTime(_time:Number):Point {			if (pts.length<=1) {				return new Point(0, 0);			}			var totalTime:Number=getDuration();			timeInRange=_time;			while (timeInRange > totalTime) {				timeInRange-=totalTime;			}			nowIndex=0;			for (var i=0; i<pts.length; i++) {				if (pts[i].time>timeInRange) {					nowIndex=i;					break;				}			}			if (nowIndex>0) {				var timea:Number=pts[nowIndex-1].time;				var pta:Point=pts[nowIndex-1].pos;				var timeb:Number=pts[nowIndex].time;				var ptb:Point=pts[nowIndex].pos;				var totalDurationBetweenThesePts:Number=timeb-timea;				var myPositionBetweenThesePts:Number=timeInRange-timea;				var pct:Number=myPositionBetweenThesePts/totalDurationBetweenThesePts;				var mix:Point=new Point(0,0);				mix.x = (1-pct) * pta.x + (pct) * ptb.x;				mix.y = (1-pct) * pta.y + (pct) * ptb.y;				//mix.z = (1-pct) * pta.z + (pct) * ptb.z;				nowDist  = (1-pct) * pts[nowIndex - 1].dist + (pct) * pts[nowIndex].dist;				nowAngle = (1-pct) * pts[nowIndex - 1].angle + (pct) * pts[nowIndex].angle;				//angle = atan2(pts[whatPointAmINear].pos.y - pts[whatPointAmINear - 1].pos.y, pts[whatPointAmINear].pos.x - pts[whatPointAmINear-1].pos.x);				return mix;			} else {				nowDist=pts[nowIndex].dist;				nowAngle=pts[nowIndex].angle;				return pts[nowIndex].pos;			}		}//getPointForTime		// --------------------------------------- update		public function update() {			if(!bLoaded || pts.length == 0) return;						// check time change to update animation			var diffTime:Number = getElapsedTime()-timeOfLastFrame;			timeOfLastFrame = getElapsedTime();			if (! bPaused) {				timeCounter+=diffTime;			}			// set current point and time			nowPointForTime = getPointForTime(timeCounter);			// check in case time jumps over end pt			if (nowIndex>ptEnd) {				nowPointForTime = getPointForTime(pts[ptEnd-1].time);			}			// test for reset -- check last point and first in case time jump goes over			// could be problematic with a fast framerate			if ( nowIndex == ptEnd  || (nowIndex == 0 && bPlayed) ) {				bReset=true;				nowPointForTime=getPointForTime(pts[ptEnd-1].time);			}			// tag has been played			bPlayed = true;			//this.graphics.moveTo(pts[0].pos.x*1024, pts[0].pos.y*768);						// calculate the 2d strip			if(pts.length > 0) {				calculateStrip(pts, 1024, 768);			}			this.graphics.clear();			for (var i = getStartPt() + 1; i<getIdCurrent(); i++) {								var tx:Number = pts[i].pos.x * 1024; //FIXME: fixed to width				var ty:Number = pts[i].pos.y * 768; //FIXME: fixed to height...				//this.graphics.lineStyle(3, 0x000000);				//this.graphics.lineTo(tx, ty);				/*        var hex = (timeCounter*2).toString(16);*/				this.graphics.beginFill(0xffffff, 1);				//this.graphics.lineStyle(1, 0xffffff);				this.graphics.moveTo(pts[i].x1, pts[i].y1);				this.graphics.lineTo(pts[i].x2, pts[i].y2);				this.graphics.lineTo(pts[i].x3, pts[i].y3);				this.graphics.lineTo(pts[i].x4, pts[i].y4);				this.graphics.lineTo(pts[i].x1, pts[i].y1);				this.graphics.endFill();			}					}//update	}}